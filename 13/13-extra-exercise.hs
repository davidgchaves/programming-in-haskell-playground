--
-- Extra Exercise: Implement foldl in terms of foldr
--

--  1 - The Universal Property of foldr
--
--    The Universal Property of foldr says that if we have some function g defined as
--      g []     = v            (BASE CASE)
--      g (x:xs) = f x (g xs)   (RECURSIVE CASE)
--    then
--      g = foldr f v
--
--    If we substitute 'foldr f v' into the definition of g we get a definition of foldr:
--      foldr f v []     = v
--      foldr f v (x:xs) = f x (foldr f v xs)
--
--
--  2 - Comparing foldl and foldr
--
--    The base case of foldr and foldl is identical
--      foldr f v [] = v
--      foldl f v [] = v
--
--    The recursive one is not
--      foldr f v (x:xs) = f x (foldr f v xs)
--      foldl f v (x:xs) = foldl f (f v x) xs
--
--
--  3 - Transforming the foldl definition
--
--    We are going to apply a transformation to the foldl definition
--    so it can be rewritten in the form
--      f x (g xs)
--
--    3.1 - The foldl definition with types
--      foldl            :: (a -> b -> a) -> a -> [b] -> a
--      foldl f a []     = a
--      foldl f a (b:bs) = foldl f (f a b) bs
--
--    3.2 - Swapping the last 2 parameters - enter foldl2
--      foldl2 f []     a = a
--      foldl2 f (b:bs) a = foldl2 f bs (f a b)
--
--    3.3 - Rewriting foldl2 base case using id and an eta-conversion
--      id: returns the input parameter unchanged (identity function)
--      foldl2 f [] a = a  --->  foldl2 f [] a = id a
--
--      eta-conversion: adding or dropping of abstraction over a function
--      foldl2 f [] a = id a  --->  foldl2 f [] = id
--
--    3.4 - Rewriting foldl2 recursive case using a lambda and an eta-conversion
--      We use a lambda to factor out the value a
--      foldl2 f (b:bs) a = (\a -> foldl2 f bs (f a b)) a
--
--      And now the eta-conversion
--      foldl2 f (b:bs) = \a -> foldl2 f bs (f a b)
--
--    3.5 - Factoring out b in foldl2 recursive case
--      We use the previous lambda to factor out the list element b
--      foldl2 f (b:bs) = (\b a -> foldl2 f bs (f a b)) b
--
--    3.6 - Factoring out 'foldl2 f bs' in foldl2 recursive case
--      And yet again, we use the previous lambda to factor out 'foldl2 f bs' (as h)
--      foldl2 f (b:bs) = (\b h a -> h (f a b)) b (foldl2 f bs)
--
--
--  4 - foldl2: the new foldl definition
--
--    This is how foldl2 is defined after all the transformations
--      foldl2 f []     = id
--      foldl2 f (b:bs) = (\b h a -> h (f a b)) b (foldl2 f bs)
--
--
--  5 - foldl2 and the "g-form" of the Universal Property of foldr
--
--    Right now we have almost managed to transform foldl
--      foldl2 f (b:bs) = (\b h a -> h (f a b)) b (foldl2 f bs)
--    into the "g-form" of the Universal Property of foldr
--      g (x:xs) = k x (g xs)
--    or more conveniently
--      g (b:bs) = k b (g bs)
--
--    Just check it out
--      g        (b:bs) = k                     b (g        bs)
--      foldl2 f (b:bs) = (\b h a -> h (f a b)) b (foldl2 f bs)
--
--    where
--      k = \b h a -> h (f a b)
--      g = foldl2 f
--
--
--  6 - Combining foldl2 and foldr using the Universal Property of foldr
--
--    Consider the Universal Property of foldr (from 1)
--      g = foldr k v
--    or more conveniently
--      g = foldr k a
--
--    and the transformed foldl (from 5)
--      g = foldl2 f
--
--    Combining both, we arrive at
--      foldl2 f = foldr k a
--
--
--  7 - foldl2 in terms of foldr
--
--    We are going to replace 'k' and 'a' in
--      foldl2 f = foldr k a
--    and then restore the removed parameters 'bs' and 'a'
--
